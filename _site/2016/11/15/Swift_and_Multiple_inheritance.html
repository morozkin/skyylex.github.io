<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Swift_and_multiple_inheritance</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Lato">
  <link rel="canonical" href="http://localhost:4000/2016/11/15/Swift_and_Multiple_inheritance.html">
  <link rel="alternate" type="application/rss+xml" title="Software Engineering blog" href="/feed.xml">
  
  
</head>

  <body>

    <style>
.common_footer {
}

.common_header {
  background-color : rgb(238,238,238);
}

.context_text { 
  text-align: left; 
  line-height: 140%;
}

.nav_anchor {
  text-decoration: underline; 
  white-space: pre; 
  vertical-align: text-bottom;
}

</style>
<header class="common_header site-header" role="banner">
  <div class="wrapper">
    <span style="float: left;">
      <div style="font-weight: bold;">Software Engineering blog</div>
      <div>&nbsp</div>
      <div>author: Yury Lapitsky</div>
      <div>e-mail: yury.lapitsky@gmail.com</div>
    </span>

    <span style="float: right;">
      <div>
        <span>
          [<a class="nav_anchor" href="/">home</a>]
        </span>
        <span>
          [<a class="nav_anchor" href="/posts">posts</a>]
        </span>
        <span>
          [<a class="nav_anchor" href="/projects">projects</a>]
        </span>
        <span>
          [<a class="nav_anchor" href="/about">about</a>]
        </span>
      </div>
      <br>
    </span>

  </div>

</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <!-- tags: swift, objc, multiple_inheritance -->

<p><strong>Swift and Multiple Inheritance.</strong></p>

<p><strong>Introduction</strong></p>

<p>I like to find out new edges in the well-known concepts. I think no need to prove that basic OOP concepts, such as incapsulation, inheritance and polymorphism are well-known. They were discussed a millions of times and I should not spend time on repeating this. However, I will put some references at the end to be precise enought for someone who needs some more info about the subject. And the subject today will be Multiple Inheritance in Swift, as the title says. Why? Because I thought that Objective-C have no support of a multiple inheritance. And Swift was extended with the default implementation for protocols which is a type of a multiple inheritance. So it’s interesting to play with the old issues in the new environment.</p>

<p><strong>Notice</strong>: before moving directly to the Swift details I want to make clear that inheritance could be classified according to the inherited subject: 1) inherited implementation 2) inherited interface. Now it’s clear that Objective-C has also multiple inheritance in terms of conforming to @protocol. However it has no issues (described further) because @protocol is just a declaration of available methods for usage.</p>

<p><strong>How multiple inheritance is presented in Swift</strong></p>

<p>Swift has such feature as a protocols. Mostly it has the same meaning as in Objective-C. The difference was made in Swift 3 when protocol was allowed to extend with the default implementation. And class(struct) which conforms to protocol will inherit this implementation. The idea is simple to share same functionality without creating separate implementation for each of the methods in each inherited class or struct. And from the first look it might look great. Unfortunately, there is a classic problem where two or more protocols (or protocol and class/strus) has exactly the same method signature. In that case there is no way for linker to choose what implementation to use in the inherited class.</p>

<p><strong>Swift, we have a problem</strong></p>

<p>The code below represents a problem. There are two protocols A and B with extensions that contains default implementations. These protocols were declared as conformed by class ConflictTarget. The Xcode output clearly displays that such configuration will not work.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>protocol A {
    func sameFunctionName()
}

extension A {
    func sameFunctionName() {
        print("method from class A")
    }
}

protocol B {
    func sameFunctionName()
}

extension B {
    func sameFunctionName() {
        print("method from class B")
    }
}

class ConflictTarget: A, B {
    
}

</code></pre>
</div>

<p><strong>Xcode console output</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>Playground execution failed: error: NamesConflict.playground:20:7: error: type 'ConflictTarget' does not conform to protocol 'A'
class ConflictTarget: A, B {
      ^

NamesConflict.playground:1:10: note: multiple matching functions named 'sameFunctionName()' with type '() -&gt; ()'
    func sameFunctionName()
         ^

NamesConflict.playground:15:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

NamesConflict.playground:5:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

error: NamesConflict.playground:20:7: error: type 'ConflictTarget' does not conform to protocol 'B'
class ConflictTarget: A, B {
      ^

NamesConflict.playground:11:10: note: multiple matching functions named 'sameFunctionName()' with type '() -&gt; ()'
    func sameFunctionName()
         ^

NamesConflict.playground:15:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

NamesConflict.playground:5:10: note: candidate exactly matches
    func sameFunctionName() {
         ^


* thread #1: tid = 0x5f41a5, 0x000000010bf513c0 NamesConflict`executePlayground, queue = 'com.apple.main-thread', stop reason = breakpoint 1.2
  * frame #0: 0x000000010bf513c0 NamesConflict`executePlayground
    frame #1: 0x000000010bf509c0 NamesConflict`__37-[XCPAppDelegate enqueueRunLoopBlock]_block_invoke + 32
    frame #2: 0x000000010ca6b25c CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
    frame #3: 0x000000010ca50304 CoreFoundation`__CFRunLoopDoBlocks + 356
    frame #4: 0x000000010ca4fa75 CoreFoundation`__CFRunLoopRun + 901
    frame #5: 0x000000010ca4f494 CoreFoundation`CFRunLoopRunSpecific + 420
    frame #6: 0x0000000111e5da6f GraphicsServices`GSEventRunModal + 161
    frame #7: 0x000000010d5fa964 UIKit`UIApplicationMain + 159
    frame #8: 0x000000010bf506e9 NamesConflict`main + 201
    frame #9: 0x000000010ffad68d libdyld.dylib`start + 1
    frame #10: 0x000000010ffad68d libdyld.dylib`start + 1
</code></pre>
</div>

<p><strong>Conclusion</strong></p>

<ol>
  <li>
    <p>“Favor object composition over class inheritance”. I agree that the case described above is rare, and if the user has control over the code related to protocols declaration and implementation it could be easily fixed. However, if all you have is binary framework there is no much to choose.</p>
  </li>
  <li>
    <p>The second issue I see is related to the functionality for protocols to inherit from the other protocols. When you use them only as API declaration it’s ok. In such case you just save time to not declare same methods twice. But if the extension with the default implementation might appear somewhere, it brings an additional mess in understanding of the system behaviour during code analysis and debugging.</p>
  </li>
</ol>

<p><strong>Thank you for reading!</strong></p>

<p><strong>References</strong></p>

<ol>
  <li><a href="https://en.wikipedia.org/wiki/Multiple_inheritance">Multiple inheritance - Wikipedia</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">Composition over inheritance - Wikipedia</a></li>
  <li><a href="https://developer.apple.com/videos/play/wwdc2015/408/">Protocol-oriented programming - WWDC 2015</a></li>
</ol>

      </div>
    </main>

    <style>
  .noprint {
    border-bottom-style : inset;
    border-bottom-width : 1px;
    border-left-style : inset;
    border-left-width : 1px;
    border-right-style : inset;
    border-right-width : 1px;
    border-top-style : inset;
    border-top-width : 1px;
  }
</style>

<footer>
  <hr class="noprint" >
  <div class="wrapper">
    <div>
      <br>
      <div class="common_footer">
        Based on 
        [<a href="https://github.com/jekyll">Jekyll</a>]
          and [<a href="https://github.com/jekyll/minima">minima</a>] theme. 
        Created on December 24, 2016
      </div>
      <br>
    </div>
  </div>

</footer>

  </body>

</html>
