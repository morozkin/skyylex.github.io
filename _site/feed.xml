<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-01-13T00:49:40+03:00</updated><id>http://localhost:4000//</id><title type="html">Software Engineering blog</title><subtitle>Software engineering blog by Yury Lapisky (aka skyylex) for everyone interested in programming,  software design, computer architectures and a little bit in computer networks. And off course Swift and Objective-C are first-class citizens here.
</subtitle><entry><title type="html">Nsobject_internals Alloc_and_init</title><link href="http://localhost:4000/2017/01/04/NSObject_internals-alloc_and_init.html" rel="alternate" type="text/html" title="Nsobject_internals Alloc_and_init" /><published>2017-01-04T00:00:00+03:00</published><updated>2017-01-04T00:00:00+03:00</updated><id>http://localhost:4000/2017/01/04/NSObject_internals-alloc_and_init</id><content type="html" xml:base="http://localhost:4000/2017/01/04/NSObject_internals-alloc_and_init.html">&lt;p&gt;&lt;strong&gt;NSObject Internals - Episode 1. Alloc &amp;amp; Init.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Introduction&lt;/p&gt;

&lt;p&gt;Today I want to start a series of posts related to investigation of the available NSObject’s source code. NSObject is one of the root classes in Objective-C and most of the core concepts of Objective-C are located there. The format of investigation will evolve, at this moment I think that the most useful description should be a combination of the info from source code and official documentation.&lt;/p&gt;

&lt;p&gt;Memory in C&lt;/p&gt;

&lt;p&gt;Objective-C memory management is built over the C foundation. To start speaking we assume that we are speaking about user mode (kernel mode is a different story) C programmer has access to a stack and heap memory. Heap memory is a memory allocated using malloc/calloc functions.&lt;/p&gt;</content><summary type="html">NSObject Internals - Episode 1. Alloc &amp;amp; Init.</summary></entry><entry><title type="html">Swift_and_multiple_inheritance</title><link href="http://localhost:4000/2016/11/15/Swift_and_Multiple_inheritance.html" rel="alternate" type="text/html" title="Swift_and_multiple_inheritance" /><published>2016-11-15T00:00:00+03:00</published><updated>2016-11-15T00:00:00+03:00</updated><id>http://localhost:4000/2016/11/15/Swift_and_Multiple_inheritance</id><content type="html" xml:base="http://localhost:4000/2016/11/15/Swift_and_Multiple_inheritance.html">&lt;!-- tags: swift, objc, multiple_inheritance --&gt;

&lt;p&gt;&lt;strong&gt;Swift and Multiple Inheritance.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I like to find out new edges in the well-known concepts. I think no need to prove that basic OOP concepts, such as incapsulation, inheritance and polymorphism are well-known. They were discussed a millions of times and I should not spend time on repeating this. However, I will put some references at the end to be precise enought for someone who needs some more info about the subject. And the subject today will be Multiple Inheritance in Swift, as the title says. Why? Because I thought that Objective-C have no support of a multiple inheritance. And Swift was extended with the default implementation for protocols which is a type of a multiple inheritance. So it’s interesting to play with the old issues in the new environment.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notice&lt;/strong&gt;: before moving directly to the Swift details I want to make clear that inheritance could be classified according to the inherited subject: 1) inherited implementation 2) inherited interface. Now it’s clear that Objective-C has also multiple inheritance in terms of conforming to @protocol. However it has no issues (described further) because @protocol is just a declaration of available methods for usage.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How multiple inheritance is presented in Swift&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Swift has such feature as a protocols. Mostly it has the same meaning as in Objective-C. The difference was made in Swift 3 when protocol was allowed to extend with the default implementation. And class(struct) which conforms to protocol will inherit this implementation. The idea is simple to share same functionality without creating separate implementation for each of the methods in each inherited class or struct. And from the first look it might look great. Unfortunately, there is a classic problem where two or more protocols (or protocol and class/strus) has exactly the same method signature. In that case there is no way for linker to choose what implementation to use in the inherited class.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Swift, we have a problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The code below represents a problem. There are two protocols A and B with extensions that contains default implementations. These protocols were declared as conformed by class ConflictTarget. The Xcode output clearly displays that such configuration will not work.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol A {
    func sameFunctionName()
}

extension A {
    func sameFunctionName() {
        print(&quot;method from class A&quot;)
    }
}

protocol B {
    func sameFunctionName()
}

extension B {
    func sameFunctionName() {
        print(&quot;method from class B&quot;)
    }
}

class ConflictTarget: A, B {
    
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Xcode console output&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Playground execution failed: error: NamesConflict.playground:20:7: error: type 'ConflictTarget' does not conform to protocol 'A'
class ConflictTarget: A, B {
      ^

NamesConflict.playground:1:10: note: multiple matching functions named 'sameFunctionName()' with type '() -&amp;gt; ()'
    func sameFunctionName()
         ^

NamesConflict.playground:15:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

NamesConflict.playground:5:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

error: NamesConflict.playground:20:7: error: type 'ConflictTarget' does not conform to protocol 'B'
class ConflictTarget: A, B {
      ^

NamesConflict.playground:11:10: note: multiple matching functions named 'sameFunctionName()' with type '() -&amp;gt; ()'
    func sameFunctionName()
         ^

NamesConflict.playground:15:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

NamesConflict.playground:5:10: note: candidate exactly matches
    func sameFunctionName() {
         ^


* thread #1: tid = 0x5f41a5, 0x000000010bf513c0 NamesConflict`executePlayground, queue = 'com.apple.main-thread', stop reason = breakpoint 1.2
  * frame #0: 0x000000010bf513c0 NamesConflict`executePlayground
    frame #1: 0x000000010bf509c0 NamesConflict`__37-[XCPAppDelegate enqueueRunLoopBlock]_block_invoke + 32
    frame #2: 0x000000010ca6b25c CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
    frame #3: 0x000000010ca50304 CoreFoundation`__CFRunLoopDoBlocks + 356
    frame #4: 0x000000010ca4fa75 CoreFoundation`__CFRunLoopRun + 901
    frame #5: 0x000000010ca4f494 CoreFoundation`CFRunLoopRunSpecific + 420
    frame #6: 0x0000000111e5da6f GraphicsServices`GSEventRunModal + 161
    frame #7: 0x000000010d5fa964 UIKit`UIApplicationMain + 159
    frame #8: 0x000000010bf506e9 NamesConflict`main + 201
    frame #9: 0x000000010ffad68d libdyld.dylib`start + 1
    frame #10: 0x000000010ffad68d libdyld.dylib`start + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;“Favor object composition over class inheritance”. I agree that the case described above is rare, and if the user has control over the code related to protocols declaration and implementation it could be easily fixed. However, if all you have is binary framework there is no much to choose.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second issue I see is related to the functionality for protocols to inherit from the other protocols. When you use them only as API declaration it’s ok. In such case you just save time to not declare same methods twice. But if the extension with the default implementation might appear somewhere, it brings an additional mess in understanding of the system behaviour during code analysis and debugging.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Thank you for reading!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_inheritance&quot;&gt;Multiple inheritance - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Composition over inheritance - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/408/&quot;&gt;Protocol-oriented programming - WWDC 2015&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><summary type="html"></summary></entry><entry><title type="html">Luminous_at_early_stages</title><link href="http://localhost:4000/2016/05/21/luminous_at_early_stages.html" rel="alternate" type="text/html" title="Luminous_at_early_stages" /><published>2016-05-21T00:00:00+03:00</published><updated>2016-05-21T00:00:00+03:00</updated><id>http://localhost:4000/2016/05/21/luminous_at_early_stages</id><content type="html" xml:base="http://localhost:4000/2016/05/21/luminous_at_early_stages.html">&lt;h3 id=&quot;luminous-project&quot;&gt;&lt;strong&gt;Luminous project&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I’ve chosen the word “Luminous” for the name of the project due to the fact that
there is a well-known association between the sun light and process of getting knowledge.
And from my opinion if the project completes as I imagine, it could put some light
on the things, which are not so easy to understand and explain.&lt;/p&gt;

&lt;p&gt;Luminous project is a try to look on the learning algorithms from another perspective. To use visualization as accompanying tool for explaining how algorithms work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;There is an obvious reason of using visualization in the explaining process. 
The most simple fact is that impact on each type of sense varies greatly in memorizing results (for each individual person).
Combining several types of sense has more chance to be remembered. 
It would be not worse to mention that complex knowledge could be explained from different angles of view. 
And like put parts of puzzle together visualization could be one of the pieces to show whole picture.&lt;/p&gt;

&lt;p&gt;Another point here is that algorithm should be very precise to accomplish it’s task. There are several requirements such as finiteness, possibility of express in formal logic and deduction of the correctness. Even not determenistic algorithms could be proven using theory of chances. But all options that were described above relate to proof and analysis (of efficiency). This is mostly about conclusion and not about the cause. And the main thought here: design of the algorithm starts from idea. (I think even far: every design starts from idea).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alternatives&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Luminous is not revolutinary project in terms that it doesn’t bring new idea of visualizing algorithms. Flowchart was developed in the 1921, so the start of the investigation such problem started in that time or even earlier. However, flowchart solve the problem in very special way. And as a fact of it’s limitations, usage of this tool was greatly decreased in the 1970th. I think it’s the result of flowchart approach, just to replace statements with figures and to connect them with line aren’t enough. Such kind of interpretation only change view and doesn’t change the complexity of explaining and learning.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Complexity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Algorithmization is very close to Math. Math uses expression with different amount of variables to describe processes. More different variables you have in a single expression more difficult to solve this expression. The same approach could be reflected on the education process. To learn something new you need to remove all additional complexity and leave only the core. After learning of core you could move to the all additional staff, because unknown variable became known. If we speak about algorithms, could learning the basic idea of algorithm first help to learn deeper all other staff? I think so.
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Update to the original post&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Related materials about this project:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/skyylex/Presentations/blob/master/luminous-at-early-stage.md&quot;&gt;Presentation during education for master degree in BSUIR, 2016&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/skyylex/Luminous-proof-of-concept&quot;&gt;Github repo with a proof of concept&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><summary type="html">Luminous project

Introduction</summary></entry></feed>
