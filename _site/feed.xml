<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-01-15T14:06:49+03:00</updated><id>http://localhost:4000//</id><title type="html">Software Engineering blog</title><subtitle>Software engineering blog by Yury Lapisky (aka skyylex) for everyone interested in programming,  software design, computer architectures and a little bit in computer networks. And off course Swift and Objective-C are first-class citizens here.
</subtitle><entry><title type="html">Nsobject internals   alloc</title><link href="http://localhost:4000/2017/01/15/NSObject-internals-alloc.html" rel="alternate" type="text/html" title="Nsobject internals   alloc" /><published>2017-01-15T00:00:00+03:00</published><updated>2017-01-15T00:00:00+03:00</updated><id>http://localhost:4000/2017/01/15/NSObject%20internals%20-%20alloc</id><content type="html" xml:base="http://localhost:4000/2017/01/15/NSObject-internals-alloc.html">&lt;p&gt;&lt;strong&gt;NSObject Internals. Episode 1 - alloc&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Today I want to start a series of posts related to investigation of the available &lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;’s source code. &lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt; is one of the root classes in Objective-C and most of the core concepts of Objective-C are located there. The format of investigation will evolve, at this moment I think that the most useful description should be a combination of the info from source code and official documentation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Official alloc&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let’s start from the available API for the &lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (id)alloc;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt; is a class method, which takes no explicit arguments and return basic &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; object. Simple enough, but not too much information here. &lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/ObjectAllocation/ObjectAllocation.html#//apple_ref/doc/uid/TP40010810-CH7-SW1&quot;&gt;Apple Developer documentation&lt;/a&gt; provides more information about what alloc should do.&lt;/p&gt;

&lt;p&gt;It says that &lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Calculate the required size and allocate memory for the object&lt;/li&gt;
  &lt;li&gt;Set retain count to 1&lt;/li&gt;
  &lt;li&gt;Set isa to the class pointer&lt;/li&gt;
  &lt;li&gt;Initialize all variables to zero&lt;/li&gt;
  &lt;li&gt;Return “raw” (uninitialized) pointer&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Also there are some references to the aligning, virtual memory, zones.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Under the hood&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The provided information is based on the objc4-706.tar.gz source code, available &lt;a href=&quot;https://opensource.apple.com/tarballs/objc4&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt; implementation starts from the sequence of calls with passing &lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt; object (pointer to struct instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_class&lt;/code&gt;). It will be logical to assume that it’s the key factor for object’s size and layout in memory.&lt;/p&gt;

&lt;p&gt;There are multiple branches of execution exist in the source code according to the compilation config and used objects. I will provide the flow which I think is used for current Objectice-C 2.0.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (id)alloc&lt;/code&gt; -&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id _objc_rootAlloc(Class cls)&lt;/code&gt; -&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)&lt;/code&gt; -&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (id)allocWithZone:(struct _NSZone *)zone&lt;/code&gt; -&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id _objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)&lt;/code&gt; -&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id class_createInstance(Class cls, size_t extraBytes)&lt;/code&gt; -&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static id _class_createInstance(Class cls, size_t extraBytes)&lt;/code&gt; -&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)&lt;/code&gt; -&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id objc_constructInstance(Class cls, void *bytes)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, last two C functions cover the most part of the job, so I will provide their code to go through.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)
{
    void *bytes;
    size_t size;

    // Can't create something for nothing
    if (!cls) return nil;

    // Allocate and initialize
    size = cls-&amp;gt;alignedInstanceSize() + extraBytes;

    // CF requires all objects be at least 16 bytes.
    if (size &amp;lt; 16) size = 16;

    if (zone) {
        bytes = malloc_zone_calloc((malloc_zone_t *)zone, 1, size);
    } else {
        bytes = calloc(1, size);
    }

    return objc_constructInstance(cls, bytes);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_class_createInstanceFromZone&lt;/code&gt; function contains 3 parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Size calculation. Basic part is retrieved in &lt;code class=&quot;highlighter-rouge&quot;&gt;cls-&amp;gt;alignedInstanceSize()&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;alignedInstanceSize&lt;/code&gt; doesn’t perform any essential calculations, instance size is already calculated in the Class object. The only additional action over size is to align it to pointer boundary.&lt;/li&gt;
  &lt;li&gt;Memory allocation. The default flow is a &lt;code class=&quot;highlighter-rouge&quot;&gt;calloc&lt;/code&gt; call. One important notice that both flows use calloc versions, that means that memory not only allocated, but also is zeroed.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Call of the &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_constructInstance&lt;/code&gt; is the final stage to work over the prepared memory.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  id objc_constructInstance(Class cls, void *bytes)
  {
      if (!cls  ||  !bytes) return nil;
        
      id obj = (id)bytes;
        
      obj-&amp;gt;initIsa(cls);

      if (cls-&amp;gt;hasCxxCtor()) {
          return object_cxxConstructFromClass(obj, cls);
      } else {
          return obj;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Main part of &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_constructInstance&lt;/code&gt; function is &lt;code class=&quot;highlighter-rouge&quot;&gt;obj-&amp;gt;initIsa(cls)&lt;/code&gt; call, where &lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt; struct’s field is set with &lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt; value. The call &lt;code class=&quot;highlighter-rouge&quot;&gt;cls-&amp;gt;hasCxxCtor()&lt;/code&gt; at first looks like something unclear. However, if to look over the rest of the objc project for &lt;code class=&quot;highlighter-rouge&quot;&gt;cxx&lt;/code&gt; names it becomes clear, that all such functionality is related to Objective-C++ implementation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Documentation for allocation process contains detailed description of the &lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject's&lt;/code&gt; behaviour.
However I didn’t mentioned anywhere above anything about setting retain counter to 1. The reason of such miss is that &lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt; doesn’t exist in the &lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt; functionality at all. &lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt; contains &lt;code class=&quot;highlighter-rouge&quot;&gt;SideTable&lt;/code&gt; struct and related methods responsible for support of reference counting in &lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;. Actual implementation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt; function has initial value equal 1. So there is no a lot of sense to mess counter with &lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;. In reality, it doesn’t touch the programmer, because from API point there is no visible difference.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Implementation tricks and details&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Analysing source code can bring new ideas and techniques, which I’ll try to share in this section.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Branch prediction.&lt;/strong&gt; There are a lot of places, where &lt;code class=&quot;highlighter-rouge&quot;&gt;fastpath()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;slowpath()&lt;/code&gt; macros are used. Macro declaration of fastpath: &lt;code class=&quot;highlighter-rouge&quot;&gt;#define fastpath(x) (__builtin_expect(bool(x), 1));&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;__builtin_expect&lt;/code&gt; could be used in &lt;code class=&quot;highlighter-rouge&quot;&gt;if-else&lt;/code&gt; statements, to tell compiler (optimizer) improve order of instructions by providing expected value of the variable. More information could be found in the official &lt;a href=&quot;http://llvm.org/docs/BranchWeightMetadata.html&quot;&gt;LLVM docs&lt;/a&gt;`.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Disable warnings for unused function arguments&lt;/strong&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;id _objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)&lt;/code&gt; doesn’t use &lt;code class=&quot;highlighter-rouge&quot;&gt;zone&lt;/code&gt; argument in the &lt;strong&gt;OBJC2&lt;/strong&gt; build, so to avoid warning additional code line was added.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // allocWithZone under __OBJC2__ ignores the zone parameter
  (void)zone;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Thank you for reading!&lt;/strong&gt;&lt;/p&gt;</content><summary type="html">NSObject Internals. Episode 1 - alloc</summary></entry><entry><title type="html">Swift_and_multiple_inheritance</title><link href="http://localhost:4000/2016/11/15/Swift_and_Multiple_inheritance.html" rel="alternate" type="text/html" title="Swift_and_multiple_inheritance" /><published>2016-11-15T00:00:00+03:00</published><updated>2016-11-15T00:00:00+03:00</updated><id>http://localhost:4000/2016/11/15/Swift_and_Multiple_inheritance</id><content type="html" xml:base="http://localhost:4000/2016/11/15/Swift_and_Multiple_inheritance.html">&lt;!-- tags: swift, objc, multiple_inheritance --&gt;

&lt;p&gt;&lt;strong&gt;Swift and Multiple Inheritance.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I like to find out new edges in the well-known concepts. I think no need to prove that basic OOP concepts, such as incapsulation, inheritance and polymorphism are well-known. They were discussed a millions of times and I should not spend time on repeating this. However, I will put some references at the end to be precise enought for someone who needs some more info about the subject. And the subject today will be Multiple Inheritance in Swift, as the title says. Why? Because I thought that Objective-C have no support of a multiple inheritance. And Swift was extended with the default implementation for protocols which is a type of a multiple inheritance. So it’s interesting to play with the old issues in the new environment.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notice&lt;/strong&gt;: before moving directly to the Swift details I want to make clear that inheritance could be classified according to the inherited subject: 1) inherited implementation 2) inherited interface. Now it’s clear that Objective-C has also multiple inheritance in terms of conforming to @protocol. However it has no issues (described further) because @protocol is just a declaration of available methods for usage.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How multiple inheritance is presented in Swift&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Swift has such feature as a protocols. Mostly it has the same meaning as in Objective-C. The difference was made in Swift 3 when protocol was allowed to extend with the default implementation. And class(struct) which conforms to protocol will inherit this implementation. The idea is simple to share same functionality without creating separate implementation for each of the methods in each inherited class or struct. And from the first look it might look great. Unfortunately, there is a classic problem where two or more protocols (or protocol and class/strus) has exactly the same method signature. In that case there is no way for linker to choose what implementation to use in the inherited class.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Swift, we have a problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The code below represents a problem. There are two protocols A and B with extensions that contains default implementations. These protocols were declared as conformed by class ConflictTarget. The Xcode output clearly displays that such configuration will not work.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol A {
    func sameFunctionName()
}

extension A {
    func sameFunctionName() {
        print(&quot;method from class A&quot;)
    }
}

protocol B {
    func sameFunctionName()
}

extension B {
    func sameFunctionName() {
        print(&quot;method from class B&quot;)
    }
}

class ConflictTarget: A, B {
    
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Xcode console output&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Playground execution failed: error: NamesConflict.playground:20:7: error: type 'ConflictTarget' does not conform to protocol 'A'
class ConflictTarget: A, B {
      ^

NamesConflict.playground:1:10: note: multiple matching functions named 'sameFunctionName()' with type '() -&amp;gt; ()'
    func sameFunctionName()
         ^

NamesConflict.playground:15:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

NamesConflict.playground:5:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

error: NamesConflict.playground:20:7: error: type 'ConflictTarget' does not conform to protocol 'B'
class ConflictTarget: A, B {
      ^

NamesConflict.playground:11:10: note: multiple matching functions named 'sameFunctionName()' with type '() -&amp;gt; ()'
    func sameFunctionName()
         ^

NamesConflict.playground:15:10: note: candidate exactly matches
    func sameFunctionName() {
         ^

NamesConflict.playground:5:10: note: candidate exactly matches
    func sameFunctionName() {
         ^


* thread #1: tid = 0x5f41a5, 0x000000010bf513c0 NamesConflict`executePlayground, queue = 'com.apple.main-thread', stop reason = breakpoint 1.2
  * frame #0: 0x000000010bf513c0 NamesConflict`executePlayground
    frame #1: 0x000000010bf509c0 NamesConflict`__37-[XCPAppDelegate enqueueRunLoopBlock]_block_invoke + 32
    frame #2: 0x000000010ca6b25c CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
    frame #3: 0x000000010ca50304 CoreFoundation`__CFRunLoopDoBlocks + 356
    frame #4: 0x000000010ca4fa75 CoreFoundation`__CFRunLoopRun + 901
    frame #5: 0x000000010ca4f494 CoreFoundation`CFRunLoopRunSpecific + 420
    frame #6: 0x0000000111e5da6f GraphicsServices`GSEventRunModal + 161
    frame #7: 0x000000010d5fa964 UIKit`UIApplicationMain + 159
    frame #8: 0x000000010bf506e9 NamesConflict`main + 201
    frame #9: 0x000000010ffad68d libdyld.dylib`start + 1
    frame #10: 0x000000010ffad68d libdyld.dylib`start + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;“Favor object composition over class inheritance”. I agree that the case described above is rare, and if the user has control over the code related to protocols declaration and implementation it could be easily fixed. However, if all you have is binary framework there is no much to choose.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second issue I see is related to the functionality for protocols to inherit from the other protocols. When you use them only as API declaration it’s ok. In such case you just save time to not declare same methods twice. But if the extension with the default implementation might appear somewhere, it brings an additional mess in understanding of the system behaviour during code analysis and debugging.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Thank you for reading!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_inheritance&quot;&gt;Multiple inheritance - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Composition over inheritance - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/408/&quot;&gt;Protocol-oriented programming - WWDC 2015&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><summary type="html"></summary></entry><entry><title type="html">Luminous_at_early_stages</title><link href="http://localhost:4000/2016/05/21/luminous_at_early_stages.html" rel="alternate" type="text/html" title="Luminous_at_early_stages" /><published>2016-05-21T00:00:00+03:00</published><updated>2016-05-21T00:00:00+03:00</updated><id>http://localhost:4000/2016/05/21/luminous_at_early_stages</id><content type="html" xml:base="http://localhost:4000/2016/05/21/luminous_at_early_stages.html">&lt;h3 id=&quot;luminous-project&quot;&gt;&lt;strong&gt;Luminous project&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I’ve chosen the word “Luminous” for the name of the project due to the fact that
there is a well-known association between the sun light and process of getting knowledge.
And from my opinion if the project completes as I imagine, it could put some light
on the things, which are not so easy to understand and explain.&lt;/p&gt;

&lt;p&gt;Luminous project is a try to look on the learning algorithms from another perspective. To use visualization as accompanying tool for explaining how algorithms work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;There is an obvious reason of using visualization in the explaining process. 
The most simple fact is that impact on each type of sense varies greatly in memorizing results (for each individual person).
Combining several types of sense has more chance to be remembered. 
It would be not worse to mention that complex knowledge could be explained from different angles of view. 
And like put parts of puzzle together visualization could be one of the pieces to show whole picture.&lt;/p&gt;

&lt;p&gt;Another point here is that algorithm should be very precise to accomplish it’s task. There are several requirements such as finiteness, possibility of express in formal logic and deduction of the correctness. Even not determenistic algorithms could be proven using theory of chances. But all options that were described above relate to proof and analysis (of efficiency). This is mostly about conclusion and not about the cause. And the main thought here: design of the algorithm starts from idea. (I think even far: every design starts from idea).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alternatives&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Luminous is not revolutinary project in terms that it doesn’t bring new idea of visualizing algorithms. Flowchart was developed in the 1921, so the start of the investigation such problem started in that time or even earlier. However, flowchart solve the problem in very special way. And as a fact of it’s limitations, usage of this tool was greatly decreased in the 1970th. I think it’s the result of flowchart approach, just to replace statements with figures and to connect them with line aren’t enough. Such kind of interpretation only change view and doesn’t change the complexity of explaining and learning.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Complexity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Algorithmization is very close to Math. Math uses expression with different amount of variables to describe processes. More different variables you have in a single expression more difficult to solve this expression. The same approach could be reflected on the education process. To learn something new you need to remove all additional complexity and leave only the core. After learning of core you could move to the all additional staff, because unknown variable became known. If we speak about algorithms, could learning the basic idea of algorithm first help to learn deeper all other staff? I think so.
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Update to the original post&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Related materials about this project:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/skyylex/Presentations/blob/master/luminous-at-early-stage.md&quot;&gt;Presentation during education for master degree in BSUIR, 2016&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/skyylex/Luminous-proof-of-concept&quot;&gt;Github repo with a proof of concept&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><summary type="html">Luminous project

Introduction</summary></entry></feed>
